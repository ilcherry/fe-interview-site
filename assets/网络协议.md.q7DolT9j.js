import{_ as i,c as a,o as t,ae as n}from"./chunks/framework.DRC4R4Ij.js";const g=JSON.parse('{"title":"网络协议","description":"","frontmatter":{},"headers":[],"relativePath":"网络协议.md","filePath":"网络协议.md"}'),l={name:"网络协议.md"};function e(h,s,o,p,r,d){return t(),a("div",null,s[0]||(s[0]=[n(`<h1 id="网络协议" tabindex="-1">网络协议 <a class="header-anchor" href="#网络协议" aria-label="Permalink to &quot;网络协议&quot;">​</a></h1><h2 id="常见的-http-code" tabindex="-1">常见的 HTTP Code <a class="header-anchor" href="#常见的-http-code" aria-label="Permalink to &quot;常见的 HTTP Code&quot;">​</a></h2><ul><li>1XX - 服务器已收到请求，正在处理，但还未完成</li><li>2XX - 请求成功，服务器已成功返回数据</li><li>3XX - 需要客户端采取进一步操作（如跳转）</li><li>4XX - 客户端请求错误，服务器无法处理</li><li>5XX - 服务器内部出错，无法完成请求</li></ul><h2 id="http2-的优点" tabindex="-1">HTTP2 的优点 <a class="header-anchor" href="#http2-的优点" aria-label="Permalink to &quot;HTTP2 的优点&quot;">​</a></h2><ul><li><strong>多路复用</strong>：在单一连接上并行处理多个请求，减少延迟。</li><li><strong>头部压缩</strong>：减少冗余的请求头和响应头，提高带宽利用率。</li><li><strong>服务器推送</strong>：允许服务器主动推送资源，减少客户端的请求次数。</li><li><strong>连接复用</strong>：减少 TCP 连接的开销。</li><li><strong>优先级控制</strong>：允许客户端设置请求的优先级，更高效地加载资源。</li><li><strong>低延迟</strong>：提高了响应速度，减少了加载时间。</li><li><strong>二进制协议</strong>：提高了协议的效率和灵活性。</li></ul><h2 id="简述-tcp-连接的过程" tabindex="-1">简述 TCP 连接的过程 <a class="header-anchor" href="#简述-tcp-连接的过程" aria-label="Permalink to &quot;简述 TCP 连接的过程&quot;">​</a></h2><p>假设 客户端（Client） 需要连接 服务器（Server），三次握手的过程如下：</p><ol><li><p>第一次握手（客户端 → 服务器，SYN） 客户端 发送 SYN（同步）报文，表示请求建立连接，并携带 初始序列号（ISN，Initial Sequence Number）。</p></li><li><p>第二次握手（服务器 → 客户端，SYN + ACK） 服务器 收到 SYN 请求后，返回 SYN + ACK 报文，表示同意连接。同时，服务器也生成自己的初始序列号（ISN_S）。</p></li><li><p>第三次握手（客户端 → 服务器，ACK） 客户端 再次发送 ACK 报文，表示确认收到服务器的 SYN，连接正式建立！此时，连接已建立，双方可以进行数据传输。</p></li></ol><h2 id="中间人攻击" tabindex="-1">中间人攻击 <a class="header-anchor" href="#中间人攻击" aria-label="Permalink to &quot;中间人攻击&quot;">​</a></h2><p>中间人攻击（Man-in-the-Middle Attack，简称 MITM） 是一种网络攻击方式，攻击者通过窃取或篡改通信双方之间的数据，从而破坏或伪造通信内容。在这种攻击中，攻击者充当通信双方之间的“中间人”，获取、修改、转发或伪造消息，通常在用户和服务之间的通信过程中悄无声息地进行</p><h2 id="反向代理与正向代理" tabindex="-1">反向代理与正向代理 <a class="header-anchor" href="#反向代理与正向代理" aria-label="Permalink to &quot;反向代理与正向代理&quot;">​</a></h2><p><strong>反向代理</strong>是指代理服务器代表目标服务器接收客户端的请求，然后将请求转发到一个或多个目标服务器。客户端并不知道自己正在与代理服务器通信，而是以为它直接在与目标服务器交互。比如负载均衡</p><p><strong>正向代理</strong>是客户端和目标服务器之间的中间服务器，通常由客户端配置，客户端将自己的请求转发给代理服务器，再由代理服务器转发给目标服务器。反过来，目标服务器的响应也会通过代理服务器返回给客户端。比如科学上网</p><h2 id="简述单点登录" tabindex="-1">简述单点登录 <a class="header-anchor" href="#简述单点登录" aria-label="Permalink to &quot;简述单点登录&quot;">​</a></h2><p>单点登录（SSO，Single Sign-On）是一种 身份认证机制，允许用户在多个系统或应用之间只需登录一次，就能访问所有相关资源，而无需重复输入用户名和密码。</p><p>举个例子</p><ul><li>场景 1：用户登录 Google 账号 后，自动访问 Gmail、YouTube、Google Drive，无需重复登录。</li><li>场景 2：用户在 企业门户 登录后，自动访问 CRM、OA、邮件系统等多个应用。</li></ul><h3 id="sso-的核心原理" tabindex="-1">SSO 的核心原理 <a class="header-anchor" href="#sso-的核心原理" aria-label="Permalink to &quot;SSO 的核心原理&quot;">​</a></h3><p>SSO 主要基于 统一身份认证，通过 共享 Token 或 Session 来实现跨系统登录。</p><p>基本流程如下：</p><ol><li>用户访问业务系统 A（未登录）。</li><li>跳转到 SSO 认证中心（统一身份认证）。</li><li>用户输入账号密码，SSO 认证成功后，生成 Token/Session 并返回给业务系统 A。</li><li>业务系统 A 记录 Token，并允许访问。</li><li>用户访问业务系统 B，系统 B 检查 Token，如果有效，则直接放行（免登录）。</li></ol><h3 id="sso-的实现方式" tabindex="-1">SSO 的实现方式 <a class="header-anchor" href="#sso-的实现方式" aria-label="Permalink to &quot;SSO 的实现方式&quot;">​</a></h3><ul><li>基于 Cookie 共享</li><li>基于 Token</li><li>基于 SAML 协议</li><li>基于 CAS</li></ul><h2 id="文件上传如何做断点续传" tabindex="-1">文件上传如何做断点续传 <a class="header-anchor" href="#文件上传如何做断点续传" aria-label="Permalink to &quot;文件上传如何做断点续传&quot;">​</a></h2><p>断点续传主要通过将文件分成多个小块（称为 分片）进行上传。每个分片在上传过程中都被单独处理，上传失败时，只需要重新上传失败的分片，而不需要从头开始上传整个文件。</p><p>断点续传的基本步骤如下：</p><ul><li><p>客户端将文件分块： 将大文件拆分成多个小块，每个块的大小可以根据需求配置，通常每块的大小会在几 MB 到几十 MB 之间。分块上传的方式有助于在上传过程中实现断点续传。</p></li><li><p>上传过程中记录上传状态： 在上传时，客户端需要记录每个块是否上传成功，通常会在客户端本地或服务器端记录每个块的上传状态。常见做法是将每个分片的上传进度保存在数据库或临时文件中。</p></li><li><p>断点续传： 如果上传过程中的网络中断或发生其他异常，客户端会根据已上传的分块信息，继续上传未上传的分块，而不需要重新上传已成功上传的部分。</p></li><li><p>服务器端合并文件： 当所有的分片都上传完成后，服务器会将这些小块按照顺序重新拼接成原始文件，完成文件的上传过程。</p></li></ul><h2 id="介绍-ssl-和-tls" tabindex="-1">介绍 SSL 和 TLS <a class="header-anchor" href="#介绍-ssl-和-tls" aria-label="Permalink to &quot;介绍 SSL 和 TLS&quot;">​</a></h2><p>SSL（Secure Sockets Layer，安全套接字层）：是一种加密通信协议，用于在客户端（浏览器）和服务器之间建立安全连接，保护数据不被窃取或篡改。</p><p>TLS（Transport Layer Security，传输层安全协议）：是 SSL 的升级版，提供更安全的加密和身份验证机制。</p><p>现代浏览器和服务器基本上都使用 TLS，而不再使用 SSL。</p><p>SSL/TLS 主要通过 握手（Handshake） 过程来建立安全连接。</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Client                       Server</span></span>
<span class="line"><span>   | ------ ClientHello ------&gt; |   // 客户端发起连接</span></span>
<span class="line"><span>   | &lt;----- ServerHello ------ |   // 服务器响应并发送证书</span></span>
<span class="line"><span>   | -- 发送对称加密密钥 --&gt; |   // 客户端用公钥加密密钥</span></span>
<span class="line"><span>   | &lt;--- 握手完成确认 ---&gt; |   // 服务器解密并确认</span></span>
<span class="line"><span>   | ---- 安全通信开始 ----&gt; |   // 开始加密传输</span></span></code></pre></div><h2 id="说说网络的五层模型" tabindex="-1">说说网络的五层模型 <a class="header-anchor" href="#说说网络的五层模型" aria-label="Permalink to &quot;说说网络的五层模型&quot;">​</a></h2><p>应用层 (Application Layer) &lt;- 用户与应用交互</p><p>传输层 (Transport Layer) &lt;- 提供端到端的数据传输服务</p><p>网络层 (Network Layer) &lt;- 处理数据包的路由与寻址</p><p>数据链路层 (Data Link Layer) &lt;- 在局部网络上传输数据帧</p><p>物理层 (Physical Layer) &lt;- 在物理介质上传输比特流</p><h2 id="get-和-post-的区别" tabindex="-1">GET 和 POST 的区别 <a class="header-anchor" href="#get-和-post-的区别" aria-label="Permalink to &quot;GET 和 POST 的区别&quot;">​</a></h2><p><strong>GET</strong> 和 <strong>POST</strong> 都是 HTTP 请求方法，用于客户端和服务器之间的数据传输，它们在使用上有一些关键的区别。下面是 GET 和 POST 的主要区别：</p><h3 id="_1-目的和用途" tabindex="-1"><strong>1. 目的和用途</strong> <a class="header-anchor" href="#_1-目的和用途" aria-label="Permalink to &quot;**1. 目的和用途**&quot;">​</a></h3><ul><li><strong>GET</strong>：主要用于从服务器获取数据。请求的数据通常附带在 URL 中。</li><li><strong>POST</strong>：主要用于向服务器发送数据，通常用于提交表单或上传文件，数据通常包含在请求体中。</li></ul><h3 id="_2-数据传输方式" tabindex="-1"><strong>2. 数据传输方式</strong> <a class="header-anchor" href="#_2-数据传输方式" aria-label="Permalink to &quot;**2. 数据传输方式**&quot;">​</a></h3><ul><li><strong>GET</strong>：数据作为查询字符串附加在 URL 后面，形式为 <code>key=value</code> 键值对，多个参数用 <code>&amp;</code> 连接。例如：<code>http://example.com?name=John&amp;age=30</code>。</li><li><strong>POST</strong>：数据被包含在请求体（body）中，不显示在 URL 中，因此适合传输较大或较敏感的数据。</li></ul><h3 id="_3-数据长度限制" tabindex="-1"><strong>3. 数据长度限制</strong> <a class="header-anchor" href="#_3-数据长度限制" aria-label="Permalink to &quot;**3. 数据长度限制**&quot;">​</a></h3><ul><li><strong>GET</strong>：由于数据被放在 URL 中，URL 的长度受到浏览器和服务器的限制。不同的浏览器和服务器对 URL 长度的限制不同，一般是 2048 字符。</li><li><strong>POST</strong>：没有明确的长度限制，理论上可以发送非常大的数据量（限制通常由服务器配置决定）。</li></ul><h3 id="_4-安全性" tabindex="-1"><strong>4. 安全性</strong> <a class="header-anchor" href="#_4-安全性" aria-label="Permalink to &quot;**4. 安全性**&quot;">​</a></h3><ul><li><strong>GET</strong>：由于数据作为查询参数附加在 URL 中，因此数据在传输过程中容易被他人窥探。尤其对于敏感信息（如用户名、密码），使用 GET 并不安全。</li><li><strong>POST</strong>：虽然数据放在请求体中，URL 中不直接显示，因此相对 GET 更加安全。特别是对于敏感数据，POST 更合适，但它并不意味着数据是加密的（除非使用 HTTPS）。</li></ul><h3 id="_5-缓存与书签" tabindex="-1"><strong>5. 缓存与书签</strong> <a class="header-anchor" href="#_5-缓存与书签" aria-label="Permalink to &quot;**5. 缓存与书签**&quot;">​</a></h3><ul><li><strong>GET</strong>：由于 GET 请求的参数是附加在 URL 中的，浏览器可以缓存 GET 请求的结果，并且可以通过 URL 直接书签（例如，保存网址）。</li><li><strong>POST</strong>：POST 请求的结果不会被缓存,也不能通过 URL 直接书签。每次提交 POST 请求都会发起新的请求。</li></ul><h3 id="_6-幂等性" tabindex="-1"><strong>6. 幂等性</strong> <a class="header-anchor" href="#_6-幂等性" aria-label="Permalink to &quot;**6. 幂等性**&quot;">​</a></h3><ul><li><strong>GET</strong>：GET 请求是幂等的（Idempotent），即同样的请求可以重复多次，结果不会改变。GET 请求应仅用于获取数据，不应对服务器状态造成任何改变。</li><li><strong>POST</strong>：POST 请求是非幂等的，每次提交 POST 请求都可能会导致不同的结果（例如，提交表单数据可能会导致数据库内容发生变化）。</li></ul><h2 id="http-劫持、dns-劫持与-xss" tabindex="-1">HTTP 劫持、DNS 劫持与 XSS <a class="header-anchor" href="#http-劫持、dns-劫持与-xss" aria-label="Permalink to &quot;HTTP 劫持、DNS 劫持与 XSS&quot;">​</a></h2><h2 id="怎样解决跨域问题" tabindex="-1">怎样解决跨域问题？ <a class="header-anchor" href="#怎样解决跨域问题" aria-label="Permalink to &quot;怎样解决跨域问题？&quot;">​</a></h2><ul><li>CORS（跨源资源共享）在服务器端设置 HTTP 头来允许跨域请求</li><li>JSONP（JSON with Padding）是一种通过标签加载资源的方式，利用 script 标签不受同源策略的限制来绕过跨域。JSONP 只支持 GET 请求，不支持其他类型的 HTTP 请求</li><li>通过设置代理服务器来中转请求，将跨域请求发送到自己控制的服务器，再由该服务器请求目标资源，获取到数据后返回给客户端。这样可以避免跨域问题，因为浏览器并不会直接向目标服务器发送请求</li><li>WebSocket 是一种双向通信协议，不受同源策略的限制。可以通过 WebSocket 实现跨域通信，尤其适用于需要实时数据交换的场景</li></ul><h2 id="简单请求-预检请求" tabindex="-1">简单请求&amp;预检请求 <a class="header-anchor" href="#简单请求-预检请求" aria-label="Permalink to &quot;简单请求&amp;预检请求&quot;">​</a></h2><p>在 <strong>跨域资源共享（CORS）</strong> 机制中，浏览器会根据请求的 <strong>类型</strong> 和 <strong>头信息</strong> 采取不同的处理方式，主要分为 <strong>简单请求（Simple Request）</strong> 和 <strong>预检请求（Preflight Request）</strong>。</p><p>🚀 <strong>1. 什么是简单请求（Simple Request）？</strong></p><p><strong>简单请求</strong> 是 <strong>符合特定条件</strong> 的跨域 HTTP 请求，浏览器<strong>不会</strong>发起预检请求，直接发送请求并接受响应。</p><h3 id="📌-简单请求的条件" tabindex="-1">📌 <strong>简单请求的条件</strong> <a class="header-anchor" href="#📌-简单请求的条件" aria-label="Permalink to &quot;📌 **简单请求的条件**&quot;">​</a></h3><p>浏览器只会将满足 <strong>以下三个条件</strong> 的请求视为 <strong>简单请求</strong>：</p><ol><li><strong>请求方法</strong> 只能是以下三种之一： <ul><li><code>GET</code></li><li><code>POST</code></li><li><code>HEAD</code></li></ul></li><li><strong>请求头</strong> 只能包含以下字段（不能自定义额外的 Header）： <ul><li><code>Accept</code></li><li><code>Accept-Language</code></li><li><code>Content-Language</code></li><li><code>Content-Type</code>（但仅限于 <code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code> 或 <code>text/plain</code>）</li></ul></li><li><strong>请求体</strong> 格式受限： <ul><li><code>application/json</code> <strong>不属于简单请求</strong>，因为 <code>application/json</code> 不在 <code>Content-Type</code> 允许的范围内。</li></ul></li></ol><h3 id="🛠-简单请求示例" tabindex="-1">🛠 <strong>简单请求示例</strong> <a class="header-anchor" href="#🛠-简单请求示例" aria-label="Permalink to &quot;🛠 **简单请求示例**&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://api.example.com/data&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  method: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;GET&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  headers: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Accept: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;application/json&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">response</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> response.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">json</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data));</span></span></code></pre></div><p>✅ <strong>请求不会触发预检，直接发送！</strong><br> ✅ 服务器 <strong>必须</strong> 在响应头中返回 <code>Access-Control-Allow-Origin</code>，否则浏览器会阻止访问。</p><h3 id="🎯-服务器响应示例" tabindex="-1">🎯 <strong>服务器响应示例</strong> <a class="header-anchor" href="#🎯-服务器响应示例" aria-label="Permalink to &quot;🎯 **服务器响应示例**&quot;">​</a></h3><div class="language-http vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">HTTP</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.1</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 200</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> OK</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Access-Control-Allow-Origin</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> *</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Content-Type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> application/json</span></span></code></pre></div><hr><p>🔥 <strong>2. 什么是预检请求（Preflight Request）？</strong></p><p>如果请求 <strong>不符合</strong> 简单请求的条件，浏览器会先发送一个 <strong>OPTIONS 预检请求</strong>，询问服务器是否允许跨域请求。</p><h3 id="📌-什么时候触发预检请求" tabindex="-1">📌 <strong>什么时候触发预检请求？</strong> <a class="header-anchor" href="#📌-什么时候触发预检请求" aria-label="Permalink to &quot;📌 **什么时候触发预检请求？**&quot;">​</a></h3><p>如果<strong>请求满足以下任意条件</strong>，浏览器会 <strong>先发一个 OPTIONS 请求</strong>：</p><ol><li><strong>请求方法不是 <code>GET</code>、<code>POST</code> 或 <code>HEAD</code></strong>（如 <code>PUT</code>、<code>DELETE</code>、<code>PATCH</code>）。</li><li><strong>请求头包含自定义字段</strong>（如 <code>Authorization</code>、<code>X-Requested-With</code>）。</li><li><strong><code>Content-Type</code> 不是 <code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code> 或 <code>text/plain</code></strong>（如 <code>application/json</code>）。</li></ol><hr><h3 id="🛠-预检请求示例" tabindex="-1">🛠 <strong>预检请求示例</strong> <a class="header-anchor" href="#🛠-预检请求示例" aria-label="Permalink to &quot;🛠 **预检请求示例**&quot;">​</a></h3><h4 id="前端请求" tabindex="-1"><strong>前端请求</strong> <a class="header-anchor" href="#前端请求" aria-label="Permalink to &quot;**前端请求**&quot;">​</a></h4><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://api.example.com/update&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  method: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;PUT&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// PUT 请求需要预检</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  headers: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;Content-Type&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;application/json&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 非允许的 Content-Type</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Authorization: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Bearer token&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 自定义 Header</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  body: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JSON</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stringify</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Alice&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">response</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> response.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">json</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data));</span></span></code></pre></div><h4 id="浏览器先发送预检请求-options" tabindex="-1"><strong>浏览器先发送预检请求（OPTIONS）</strong> <a class="header-anchor" href="#浏览器先发送预检请求-options" aria-label="Permalink to &quot;**浏览器先发送预检请求（OPTIONS）**&quot;">​</a></h4><div class="language-http vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">OPTIONS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /update </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">HTTP</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.1</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Origin</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> https://example.com</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Access-Control-Request-Method</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> PUT</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Access-Control-Request-Headers</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Authorization, Content-Type</span></span></code></pre></div><h4 id="服务器返回允许跨域" tabindex="-1"><strong>服务器返回允许跨域</strong> <a class="header-anchor" href="#服务器返回允许跨域" aria-label="Permalink to &quot;**服务器返回允许跨域**&quot;">​</a></h4><div class="language-http vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">HTTP</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.1</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 204</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> No Content</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Access-Control-Allow-Origin</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> https://example.com</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Access-Control-Allow-Methods</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> PUT, POST, GET</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Access-Control-Allow-Headers</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Authorization, Content-Type</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Access-Control-Max-Age</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 86400</span></span></code></pre></div><h4 id="然后浏览器才真正发送-put-请求" tabindex="-1"><strong>然后浏览器才真正发送 PUT 请求</strong> <a class="header-anchor" href="#然后浏览器才真正发送-put-请求" aria-label="Permalink to &quot;**然后浏览器才真正发送 PUT 请求**&quot;">​</a></h4><div class="language-http vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">PUT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /update </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">HTTP</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.1</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Origin</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> https://example.com</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Authorization</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Bearer token</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Content-Type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> application/json</span></span></code></pre></div><p>✅ <strong>服务器必须正确响应 <code>Access-Control-Allow-*</code> 头，否则浏览器会拦截请求。</strong><br> ✅ <code>Access-Control-Max-Age: 86400</code> 表示 <strong>24 小时内不用再发送预检请求</strong>（提升性能）。</p><hr><p>🎯 <strong>3. 预检请求 vs. 简单请求</strong></p><table tabindex="0"><thead><tr><th>对比项</th><th>简单请求（Simple Request）</th><th>预检请求（Preflight Request）</th></tr></thead><tbody><tr><td><strong>触发条件</strong></td><td>满足简单请求的 3 个条件</td><td>请求方法不是 GET/POST/HEAD，或含自定义头</td></tr><tr><td><strong>是否发送 OPTIONS 预检</strong></td><td>❌ 否</td><td>✅ 是</td></tr><tr><td><strong>请求头限制</strong></td><td>只能使用基本头部</td><td>可以使用自定义头部</td></tr><tr><td><strong>性能</strong></td><td>更快（少一次请求）</td><td>需要先发送预检请求（性能稍差）</td></tr><tr><td><strong>应用场景</strong></td><td>常见的 <code>GET</code> 或 <code>POST</code> 表单提交</td><td>API 认证（<code>Authorization</code>）、<code>PUT/DELETE</code> 请求</td></tr></tbody></table><hr><p>🎉 <strong>总结</strong></p><ol><li><strong>简单请求</strong>： <ul><li>只有 <code>GET</code>、<code>POST</code>、<code>HEAD</code> 方法</li><li>头信息受限（不能包含 <code>Authorization</code>、<code>Custom-Header</code> 等）</li><li><code>Content-Type</code> 只能是 <code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code> 或 <code>text/plain</code></li><li><strong>不会触发预检请求</strong></li></ul></li><li><strong>预检请求</strong>： <ul><li>任何 <strong>不符合</strong> 简单请求条件的请求</li><li>先发 <code>OPTIONS</code> 请求，询问服务器是否允许跨域</li><li>服务器必须返回 <code>Access-Control-Allow-*</code> 头，否则请求被拦截</li></ul></li></ol><p>🚀 <strong>优化建议</strong></p><ul><li><strong>尽量使用简单请求</strong> 避免额外的预检请求，提高性能。</li><li><strong>增加 <code>Access-Control-Max-Age</code></strong>，减少重复预检请求的开销。</li><li><strong>服务器配置 CORS 规则</strong>，正确返回 <code>Access-Control-Allow-*</code> 头。</li></ul><h2 id="为什么使用分布式锁" tabindex="-1">为什么使用分布式锁？ <a class="header-anchor" href="#为什么使用分布式锁" aria-label="Permalink to &quot;为什么使用分布式锁？&quot;">​</a></h2><p>在分布式系统中，多个节点（服务器）可能会同时操作共享数据（如数据库、缓存、文件等） 为了防止数据竞争，数据不一致或超卖问题，需要分布式锁来确保同一时间只有一个节点能够访问某个关机资源</p><ul><li>比如用户更新个人资料，不用锁的话，会导致修改冲突，导致数据库状态不一致，导致线上事故</li><li>电商平台的秒杀活动，如果多个服务器读取库存值，最后导致库存为负，产生数据库状态问题</li></ul><h2 id="网络安全" tabindex="-1">网络安全 <a class="header-anchor" href="#网络安全" aria-label="Permalink to &quot;网络安全&quot;">​</a></h2><p>CSRF（Cross-Site Request Forgery，跨站请求伪造） 是一种利用用户身份在已登录的网站执行未授权操作的攻击。攻击者诱导用户访问恶意网站，从而在受害者不知情的情况下，以用户身份对目标网站执行操作（如转账、修改密码等）。</p><ul><li>攻击者借助用户的登录状态，在后台“冒充”用户发送恶意请求，导致用户账号被操作！</li></ul>`,99)]))}const c=i(l,[["render",e]]);export{g as __pageData,c as default};
