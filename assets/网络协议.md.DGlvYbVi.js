import{_ as t,c as r,o as l,ae as o}from"./chunks/framework.DRC4R4Ij.js";const u=JSON.parse('{"title":"网络协议","description":"","frontmatter":{},"headers":[],"relativePath":"网络协议.md","filePath":"网络协议.md"}'),e={name:"网络协议.md"};function i(n,a,s,h,d,c){return l(),r("div",null,a[0]||(a[0]=[o('<h1 id="网络协议" tabindex="-1">网络协议 <a class="header-anchor" href="#网络协议" aria-label="Permalink to &quot;网络协议&quot;">​</a></h1><h2 id="常见的-http-code" tabindex="-1">常见的 HTTP Code <a class="header-anchor" href="#常见的-http-code" aria-label="Permalink to &quot;常见的 HTTP Code&quot;">​</a></h2><ul><li>1XX - 服务器已收到请求，正在处理，但还未完成</li><li>2XX - 请求成功，服务器已成功返回数据</li><li>3XX - 需要客户端采取进一步操作（如跳转）</li><li>4XX - 客户端请求错误，服务器无法处理</li><li>5XX - 服务器内部出错，无法完成请求</li></ul><h2 id="http2-的优点" tabindex="-1">HTTP2 的优点 <a class="header-anchor" href="#http2-的优点" aria-label="Permalink to &quot;HTTP2 的优点&quot;">​</a></h2><ul><li><strong>多路复用</strong>：在单一连接上并行处理多个请求，减少延迟。</li><li><strong>头部压缩</strong>：减少冗余的请求头和响应头，提高带宽利用率。</li><li><strong>服务器推送</strong>：允许服务器主动推送资源，减少客户端的请求次数。</li><li><strong>连接复用</strong>：减少 TCP 连接的开销。</li><li><strong>优先级控制</strong>：允许客户端设置请求的优先级，更高效地加载资源。</li><li><strong>低延迟</strong>：提高了响应速度，减少了加载时间。</li><li><strong>二进制协议</strong>：提高了协议的效率和灵活性。</li></ul><h2 id="简述-tcp-连接的过程" tabindex="-1">简述 TCP 连接的过程 <a class="header-anchor" href="#简述-tcp-连接的过程" aria-label="Permalink to &quot;简述 TCP 连接的过程&quot;">​</a></h2><h2 id="中间人攻击" tabindex="-1">中间人攻击 <a class="header-anchor" href="#中间人攻击" aria-label="Permalink to &quot;中间人攻击&quot;">​</a></h2><p>中间人攻击（Man-in-the-Middle Attack，简称 MITM） 是一种网络攻击方式，攻击者通过窃取或篡改通信双方之间的数据，从而破坏或伪造通信内容。在这种攻击中，攻击者充当通信双方之间的“中间人”，获取、修改、转发或伪造消息，通常在用户和服务之间的通信过程中悄无声息地进行</p><h2 id="反向代理与正向代理" tabindex="-1">反向代理与正向代理 <a class="header-anchor" href="#反向代理与正向代理" aria-label="Permalink to &quot;反向代理与正向代理&quot;">​</a></h2><p><strong>反向代理</strong>是指代理服务器代表目标服务器接收客户端的请求，然后将请求转发到一个或多个目标服务器。客户端并不知道自己正在与代理服务器通信，而是以为它直接在与目标服务器交互。比如负载均衡</p><p><strong>正向代理</strong>是客户端和目标服务器之间的中间服务器，通常由客户端配置，客户端将自己的请求转发给代理服务器，再由代理服务器转发给目标服务器。反过来，目标服务器的响应也会通过代理服务器返回给客户端。比如科学上网</p><h2 id="简述单点登录" tabindex="-1">简述单点登录 <a class="header-anchor" href="#简述单点登录" aria-label="Permalink to &quot;简述单点登录&quot;">​</a></h2><h2 id="文件上传如何做断点续传" tabindex="-1">文件上传如何做断点续传 <a class="header-anchor" href="#文件上传如何做断点续传" aria-label="Permalink to &quot;文件上传如何做断点续传&quot;">​</a></h2><p>断点续传主要通过将文件分成多个小块（称为 分片）进行上传。每个分片在上传过程中都被单独处理，上传失败时，只需要重新上传失败的分片，而不需要从头开始上传整个文件。</p><p>断点续传的基本步骤如下：</p><ul><li><p>客户端将文件分块： 将大文件拆分成多个小块，每个块的大小可以根据需求配置，通常每块的大小会在几 MB 到几十 MB 之间。分块上传的方式有助于在上传过程中实现断点续传。</p></li><li><p>上传过程中记录上传状态： 在上传时，客户端需要记录每个块是否上传成功，通常会在客户端本地或服务器端记录每个块的上传状态。常见做法是将每个分片的上传进度保存在数据库或临时文件中。</p></li><li><p>断点续传： 如果上传过程中的网络中断或发生其他异常，客户端会根据已上传的分块信息，继续上传未上传的分块，而不需要重新上传已成功上传的部分。</p></li><li><p>服务器端合并文件： 当所有的分片都上传完成后，服务器会将这些小块按照顺序重新拼接成原始文件，完成文件的上传过程。</p></li></ul><h2 id="介绍-ssl-和-tls" tabindex="-1">介绍 SSL 和 TLS <a class="header-anchor" href="#介绍-ssl-和-tls" aria-label="Permalink to &quot;介绍 SSL 和 TLS&quot;">​</a></h2><h2 id="说说网络的五层模型" tabindex="-1">说说网络的五层模型 <a class="header-anchor" href="#说说网络的五层模型" aria-label="Permalink to &quot;说说网络的五层模型&quot;">​</a></h2><p>应用层 (Application Layer) &lt;- 用户与应用交互</p><p>传输层 (Transport Layer) &lt;- 提供端到端的数据传输服务</p><p>网络层 (Network Layer) &lt;- 处理数据包的路由与寻址</p><p>数据链路层 (Data Link Layer) &lt;- 在局部网络上传输数据帧</p><p>物理层 (Physical Layer) &lt;- 在物理介质上传输比特流</p><h2 id="get-和-post-的区别" tabindex="-1">GET 和 POST 的区别 <a class="header-anchor" href="#get-和-post-的区别" aria-label="Permalink to &quot;GET 和 POST 的区别&quot;">​</a></h2><p><strong>GET</strong> 和 <strong>POST</strong> 都是 HTTP 请求方法，用于客户端和服务器之间的数据传输，它们在使用上有一些关键的区别。下面是 GET 和 POST 的主要区别：</p><h3 id="_1-目的和用途" tabindex="-1"><strong>1. 目的和用途</strong> <a class="header-anchor" href="#_1-目的和用途" aria-label="Permalink to &quot;**1. 目的和用途**&quot;">​</a></h3><ul><li><strong>GET</strong>：主要用于从服务器获取数据。请求的数据通常附带在 URL 中。</li><li><strong>POST</strong>：主要用于向服务器发送数据，通常用于提交表单或上传文件，数据通常包含在请求体中。</li></ul><h3 id="_2-数据传输方式" tabindex="-1"><strong>2. 数据传输方式</strong> <a class="header-anchor" href="#_2-数据传输方式" aria-label="Permalink to &quot;**2. 数据传输方式**&quot;">​</a></h3><ul><li><strong>GET</strong>：数据作为查询字符串附加在 URL 后面，形式为 <code>key=value</code> 键值对，多个参数用 <code>&amp;</code> 连接。例如：<code>http://example.com?name=John&amp;age=30</code>。</li><li><strong>POST</strong>：数据被包含在请求体（body）中，不显示在 URL 中，因此适合传输较大或较敏感的数据。</li></ul><h3 id="_3-数据长度限制" tabindex="-1"><strong>3. 数据长度限制</strong> <a class="header-anchor" href="#_3-数据长度限制" aria-label="Permalink to &quot;**3. 数据长度限制**&quot;">​</a></h3><ul><li><strong>GET</strong>：由于数据被放在 URL 中，URL 的长度受到浏览器和服务器的限制。不同的浏览器和服务器对 URL 长度的限制不同，一般是 2048 字符。</li><li><strong>POST</strong>：没有明确的长度限制，理论上可以发送非常大的数据量（限制通常由服务器配置决定）。</li></ul><h3 id="_4-安全性" tabindex="-1"><strong>4. 安全性</strong> <a class="header-anchor" href="#_4-安全性" aria-label="Permalink to &quot;**4. 安全性**&quot;">​</a></h3><ul><li><strong>GET</strong>：由于数据作为查询参数附加在 URL 中，因此数据在传输过程中容易被他人窥探。尤其对于敏感信息（如用户名、密码），使用 GET 并不安全。</li><li><strong>POST</strong>：虽然数据放在请求体中，URL 中不直接显示，因此相对 GET 更加安全。特别是对于敏感数据，POST 更合适，但它并不意味着数据是加密的（除非使用 HTTPS）。</li></ul><h3 id="_5-缓存与书签" tabindex="-1"><strong>5. 缓存与书签</strong> <a class="header-anchor" href="#_5-缓存与书签" aria-label="Permalink to &quot;**5. 缓存与书签**&quot;">​</a></h3><ul><li><strong>GET</strong>：由于 GET 请求的参数是附加在 URL 中的，浏览器可以缓存 GET 请求的结果，并且可以通过 URL 直接书签（例如，保存网址）。</li><li><strong>POST</strong>：POST 请求的结果不会被缓存，也不能通过 URL 直接书签。每次提交 POST 请求都会发起新的请求。</li></ul><h3 id="_6-幂等性" tabindex="-1"><strong>6. 幂等性</strong> <a class="header-anchor" href="#_6-幂等性" aria-label="Permalink to &quot;**6. 幂等性**&quot;">​</a></h3><ul><li><strong>GET</strong>：GET 请求是幂等的（Idempotent），即同样的请求可以重复多次，结果不会改变。GET 请求应仅用于获取数据，不应对服务器状态造成任何改变。</li><li><strong>POST</strong>：POST 请求是非幂等的，每次提交 POST 请求都可能会导致不同的结果（例如，提交表单数据可能会导致数据库内容发生变化）。</li></ul><h2 id="http-劫持、dns-劫持与-xss" tabindex="-1">HTTP 劫持、DNS 劫持与 XSS <a class="header-anchor" href="#http-劫持、dns-劫持与-xss" aria-label="Permalink to &quot;HTTP 劫持、DNS 劫持与 XSS&quot;">​</a></h2><h2 id="怎样解决跨域问题" tabindex="-1">怎样解决跨域问题？ <a class="header-anchor" href="#怎样解决跨域问题" aria-label="Permalink to &quot;怎样解决跨域问题？&quot;">​</a></h2>',39)]))}const T=t(e,[["render",i]]);export{u as __pageData,T as default};
