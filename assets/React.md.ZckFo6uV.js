import{_ as a,c as t,o as r,ae as i}from"./chunks/framework.DRC4R4Ij.js";const l="/fe-interview-site/assets/react_lifecycle.ndP_TnG-.png",o="/fe-interview-site/assets/vue3_lifecycle.DOf_8WQG.png",b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"React.md","filePath":"React.md"}'),u={name:"React.md"};function c(s,e,n,d,h,p){return r(),t("div",null,e[0]||(e[0]=[i('<h2 id="什么是-virtual-dom" tabindex="-1">什么是 Virtual DOM? <a class="header-anchor" href="#什么是-virtual-dom" aria-label="Permalink to &quot;什么是 Virtual DOM?&quot;">​</a></h2><p>Virtual DOM 是对实际 DOM 的一种轻量级抽象。它是一个 JavaScript 对象，表示了 DOM 的结构和状态。虚拟 DOM 本质上是页面 UI 的一个内存表示，它与实际 DOM 对应，但它并不会直接操作页面中的 DOM 元素，在更新 UI 时，不直接操作浏览器中的 DOM，而是先通过虚拟 DOM 更新 UI，最后再根据虚拟 DOM 和实际 DOM 的差异进行高效的更新，最后利用操作 DOM 的方法更新 DOM</p><h2 id="react-组件之间如何通信" tabindex="-1">React 组件之间如何通信？ <a class="header-anchor" href="#react-组件之间如何通信" aria-label="Permalink to &quot;React 组件之间如何通信？&quot;">​</a></h2><ul><li>父组件通过 props 向子组件传递状态</li><li>子组件通过回调方法更新父组件的状态</li><li>兄弟组件通过状态提升到最近的共同父组件或者状态管理工具通信</li></ul><h2 id="详解-react-hooks-的生命周期" tabindex="-1">详解 React Hooks 的生命周期 <a class="header-anchor" href="#详解-react-hooks-的生命周期" aria-label="Permalink to &quot;详解 React Hooks 的生命周期&quot;">​</a></h2><p><img src="'+l+'" alt="React Lifecycle"></p><h2 id="react-的重渲染" tabindex="-1">React 的重渲染 <a class="header-anchor" href="#react-的重渲染" aria-label="Permalink to &quot;React 的重渲染&quot;">​</a></h2><ol><li>组件的 state 变化</li><li>父组件重渲染导致子组件也重渲染</li><li>组件接收到新的 props</li><li>context 变化导致所有消费组件重渲染</li></ol><h2 id="为什么-react-渲染列表时需要加上-key" tabindex="-1">为什么 React 渲染列表时需要加上 key？ <a class="header-anchor" href="#为什么-react-渲染列表时需要加上-key" aria-label="Permalink to &quot;为什么 React 渲染列表时需要加上 key？&quot;">​</a></h2><p>在 React 渲染列表时，需要为每个列表项添加 key，其主要原因是 提升性能并减少不必要的 DOM 操作</p><h2 id="如何理解-fiber-架构" tabindex="-1">如何理解 Fiber 架构 <a class="header-anchor" href="#如何理解-fiber-架构" aria-label="Permalink to &quot;如何理解 Fiber 架构&quot;">​</a></h2><h2 id="redux-的原理-react-redux-的原理" tabindex="-1">Redux 的原理&amp;React-Redux 的原理 <a class="header-anchor" href="#redux-的原理-react-redux-的原理" aria-label="Permalink to &quot;Redux 的原理&amp;React-Redux 的原理&quot;">​</a></h2><p>Redux 的原理是发布订阅模式，React-Redux 的原理是 React.Context+useContext</p><h2 id="vue2-与-vue3-的双向绑定原理" tabindex="-1">vue2 与 vue3 的双向绑定原理 <a class="header-anchor" href="#vue2-与-vue3-的双向绑定原理" aria-label="Permalink to &quot;vue2 与 vue3 的双向绑定原理&quot;">​</a></h2><h3 id="vue2-的双向绑定原理" tabindex="-1">vue2 的双向绑定原理 <a class="header-anchor" href="#vue2-的双向绑定原理" aria-label="Permalink to &quot;vue2 的双向绑定原理&quot;">​</a></h3><p>Vue2 的双向绑定主要是通过 Object.defineProperty 实现的，它利用了 JavaScript 的 getter 和 setter 来监听数据的变化，并通过更新视图来实现双向绑定。</p><ul><li><p>数据劫持： Vue2 在创建 Vue 实例时，会遍历 data 对象中的每个属性，并使用 Object.defineProperty() 将这些属性转换为 getter 和 setter。当属性值发生变化时，setter 会被触发，进而通知视图更新。</p></li><li><p>视图更新： 当数据发生变化时，setter 会将视图组件中的依赖（即需要该数据的视图）收集到一个依赖管理器中。视图更新时，Vue2 会通过通知这些依赖进行重新渲染。</p></li></ul><h3 id="vue3-的双向绑定原理" tabindex="-1">vue3 的双向绑定原理 <a class="header-anchor" href="#vue3-的双向绑定原理" aria-label="Permalink to &quot;vue3 的双向绑定原理&quot;">​</a></h3><p>Vue3 相比 Vue2 在双向绑定的实现上进行了优化，核心的变化是使用了 Proxy 来取代 Object.defineProperty，使得 Vue3 在性能、灵活性等方面有了显著提升。</p><ul><li><p>数据劫持： Vue3 使用 Proxy 对整个数据对象进行代理。与 Object.defineProperty 不同，Proxy 可以拦截对象的所有操作（包括属性访问、修改、删除等），并通过 getter 和 setter 实现对数据变化的监听。</p></li><li><p>视图更新： Vue3 的响应式系统通过 依赖收集 和 依赖触发 来更新视图。当访问数据时，Proxy 会触发 get 方法，收集依赖；当数据修改时，set 方法会被触发，从而通知依赖进行更新。</p></li></ul><h2 id="vue3-的生命周期" tabindex="-1">Vue3 的生命周期 <a class="header-anchor" href="#vue3-的生命周期" aria-label="Permalink to &quot;Vue3 的生命周期&quot;">​</a></h2><p><img src="'+o+'" alt="vue3_lifecycle"></p><h2 id="vue3-0-有什么更新" tabindex="-1">Vue3.0 有什么更新 <a class="header-anchor" href="#vue3-0-有什么更新" aria-label="Permalink to &quot;Vue3.0 有什么更新&quot;">​</a></h2>',23)]))}const x=a(u,[["render",c]]);export{b as __pageData,x as default};
