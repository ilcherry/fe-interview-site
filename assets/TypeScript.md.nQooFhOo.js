import{_ as i,c as a,o as t,ae as n}from"./chunks/framework.DRC4R4Ij.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"TypeScript.md","filePath":"TypeScript.md"}'),p={name:"TypeScript.md"};function e(l,s,h,r,k,d){return t(),a("div",null,s[0]||(s[0]=[n(`<h2 id="说说你对-typescript-的理解-与-javascript-的区别" tabindex="-1">说说你对 TypeScript 的理解，与 JavaScript 的区别？ <a class="header-anchor" href="#说说你对-typescript-的理解-与-javascript-的区别" aria-label="Permalink to &quot;说说你对 TypeScript 的理解，与 JavaScript 的区别？&quot;">​</a></h2><p>TypeScript（简称 <strong>TS</strong>）是 <strong>JavaScript 的超集</strong>，它在 JavaScript 的基础上增加了 <strong>静态类型检查</strong>、<strong>接口</strong>、<strong>泛型</strong>等功能，使代码更<strong>安全</strong>、<strong>可维护</strong>，并且支持最新的 JavaScript 语法（ESNext）。</p><p><strong>简单来说</strong>：</p><ul><li><strong>JavaScript</strong> 是 <strong>动态类型</strong> 语言，运行时才检查类型错误。</li><li><strong>TypeScript</strong> 是 <strong>静态类型</strong> 语言，在编译阶段就能发现错误，避免运行时报错。</li></ul><h3 id="typescript-和-javascript-的核心区别" tabindex="-1"><strong>TypeScript 和 JavaScript 的核心区别</strong> <a class="header-anchor" href="#typescript-和-javascript-的核心区别" aria-label="Permalink to &quot;**TypeScript 和 JavaScript 的核心区别**&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>对比项</strong></th><th><strong>JavaScript（JS）</strong></th><th><strong>TypeScript（TS）</strong></th></tr></thead><tbody><tr><td><strong>类型系统</strong></td><td><strong>动态类型</strong>（运行时检查）</td><td><strong>静态类型</strong>（编译时检查）</td></tr><tr><td><strong>错误检测</strong></td><td>运行时才会发现错误</td><td>编译阶段就能发现错误</td></tr><tr><td><strong>可读性 &amp; 维护性</strong></td><td>代码无类型提示，易出错</td><td>代码有类型约束，维护更方便</td></tr><tr><td><strong>面向对象支持</strong></td><td>基于原型（Prototype）</td><td>支持接口、泛型、抽象类等</td></tr><tr><td><strong>ES6+ 支持</strong></td><td>需 Babel 转译</td><td>原生支持 ES6+ 语法</td></tr><tr><td><strong>运行方式</strong></td><td>直接在浏览器/Node.js 运行</td><td>需要先编译成 JavaScript</td></tr></tbody></table><h3 id="总结" tabindex="-1"><strong>总结</strong> <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;**总结**&quot;">​</a></h3><ul><li><strong>TypeScript 让 JavaScript 更安全、可维护，减少运行时错误</strong>。</li><li><strong>缺点</strong>：需要<strong>编译</strong>，学习成本稍高，但<strong>大型项目</strong>里非常值得用。</li><li><strong>适用场景</strong>：适用于 <strong>前端（React/Vue/Angular）</strong> 和 <strong>后端（Node.js）</strong> 开发，特别是<strong>大型团队合作</strong>。</li></ul><hr><p><strong>大白话</strong>：TypeScript = <strong>加了类型系统的 JavaScript，更安全、更强大、更适合大型项目</strong>！</p><h2 id="typescript-的数据类型有哪些" tabindex="-1">TypeScript 的数据类型有哪些？ <a class="header-anchor" href="#typescript-的数据类型有哪些" aria-label="Permalink to &quot;TypeScript 的数据类型有哪些？&quot;">​</a></h2><p>有 <code>number</code>、<code>string</code>、<code>boolean</code>、<code>bigint</code>、<code>symbol</code>、<code>null</code>、<code>undefined</code>、<code>Array</code>、<code>Tuple</code>、<code>Object</code>、<code>Enum</code>、<code>any</code>、<code>unknown</code>、<code>void</code>、<code>never</code>、联合类型、交叉类型、类型别名、类型断言、<code>interface</code>、<code>type</code></p><h2 id="说说对-typescript-中命名空间与模块的理解-区别" tabindex="-1">说说对 TypeScript 中命名空间与模块的理解？区别？ <a class="header-anchor" href="#说说对-typescript-中命名空间与模块的理解-区别" aria-label="Permalink to &quot;说说对 TypeScript 中命名空间与模块的理解？区别？&quot;">​</a></h2><h3 id="命名空间" tabindex="-1">命名空间 <a class="header-anchor" href="#命名空间" aria-label="Permalink to &quot;命名空间&quot;">​</a></h3><p>命名空间是一种内部模块，通过 namespace 关键字定义，主要用于在全局作用域下组织代码，避免变量污染。适用于 无需模块化的全局代码组织（如 UMD 库）。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Utils</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> greet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`Hello, \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}!\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用命名空间</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Utils.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">greet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Alice&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span></code></pre></div><ul><li>export 关键字必须添加，否则命名空间内的内容对外不可见。</li><li>命名空间的使用不需要 import，直接通过 Utils.greet() 访问。</li></ul><p>适用场景:</p><ul><li>适用于 浏览器环境（传统 JS 没有模块加载器时）。</li><li>大型项目的全局工具库（如 Utils、MathHelper）。</li></ul><h3 id="模块" tabindex="-1">模块 <a class="header-anchor" href="#模块" aria-label="Permalink to &quot;模块&quot;">​</a></h3><p>TypeScript 的模块是 基于 ES6 模块语法（import/export） 进行组织的，用于 现代前端项目（React、Vue、Node.js 等），需要模块化管理代码，每个 .ts/.tsx 文件默认就是一个模块（如果使用 import/export）。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// utils.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> greet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`Hello, \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}!\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// main.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { greet } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;./utils&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">greet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Bob&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span></code></pre></div><ul><li>export 让 greet 在 utils.ts 之外可见，import 用于引入模块。</li><li>模块的加载是基于 CommonJS（Node.js）或 ES6 模块系统（ESM），需要 import 导入。</li></ul><p>适用场景：</p><ul><li>适用于 所有现代 JS/TS 项目，特别是基于 Node.js、Webpack、Vite、Bun 的项目。</li><li>推荐使用模块，而不是命名空间，因为 ES6 模块是现代 JavaScript 标准。</li></ul><p>总结：现在推荐使用模块而不是命名空间！！！</p><h2 id="typescript-中的泛型是什么" tabindex="-1">TypeScript 中的泛型是什么？ <a class="header-anchor" href="#typescript-中的泛型是什么" aria-label="Permalink to &quot;TypeScript 中的泛型是什么？&quot;">​</a></h2><p>泛型（Generics） 是 TypeScript 提供的一种 让代码更通用、更灵活的方式，它允许你在编写代码时不预先指定具体的类型，而是在使用时再指定具体的类型。</p><p>为什么需要泛型？</p><ul><li>复用性：编写可复用的函数、类、接口，而不局限于某种特定类型。</li><li>类型安全：比 any 更安全，能够在编译时检查类型，而不会丢失类型信息。</li><li>灵活性：让代码适用于不同的数据类型，提高可扩展性。</li></ul><h2 id="什么是-typescript-的方法重载" tabindex="-1">什么是 TypeScript 的方法重载？ <a class="header-anchor" href="#什么是-typescript-的方法重载" aria-label="Permalink to &quot;什么是 TypeScript 的方法重载？&quot;">​</a></h2><p>方法重载（Function Overloading） 是指同一个函数可以根据不同的参数类型和数量，执行不同的逻辑。</p><p>在 TypeScript 中，虽然 JavaScript 不支持真正的函数重载，但 TypeScript 通过函数声明（签名）+ 实现的方式模拟了方法重载。</p><p>在 TypeScript 中，方法重载的语法包括：</p><ol><li>多个函数签名（Overload Signatures）：定义不同参数组合的函数声明。</li><li>一个具体的函数实现（Implementation）：包含具体的逻辑，并兼容所有签名。</li></ol><p>示例：同一个 greet 函数可以接收不同的参数类型</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1️⃣ 定义多个重载签名</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> greet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> greet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">age</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2️⃣ 实现函数（必须兼容所有重载）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> greet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">age</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> undefined</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`Hello, \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}. You are \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">age</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">} years old.\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`Hello, \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}.\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3️⃣ 调用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">greet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Alice&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅ &quot;Hello, Alice.&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">greet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Bob&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅ &quot;Hello, Bob. You are 30 years old.&quot;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// console.log(greet(42));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // ❌ 错误：参数类型不匹配</span></span></code></pre></div><h3 id="typescript-支持的访问修饰符有哪些" tabindex="-1">TypeScript 支持的访问修饰符有哪些？ <a class="header-anchor" href="#typescript-支持的访问修饰符有哪些" aria-label="Permalink to &quot;TypeScript 支持的访问修饰符有哪些？&quot;">​</a></h3><p>在 TypeScript 中，访问修饰符用于控制类的属性和方法的可见性，防止不必要的外部访问，提升代码的封装性和安全性。</p><p>TypeScript 支持的三种访问修饰符：</p><table tabindex="0"><thead><tr><th>修饰符</th><th>作用</th></tr></thead><tbody><tr><td><code>public</code>（默认）</td><td>任何地方都可以访问</td></tr><tr><td><code>private</code></td><td>只能在类的<strong>内部</strong>访问</td></tr><tr><td><code>protected</code></td><td>只能在类的<strong>内部</strong>或<strong>子类</strong>访问</td></tr></tbody></table>`,41)]))}const E=i(p,[["render",e]]);export{g as __pageData,E as default};
