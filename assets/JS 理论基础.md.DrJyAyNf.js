import{_ as e,c as s,o as t,ae as n}from"./chunks/framework.DRC4R4Ij.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"JS 理论基础.md","filePath":"JS 理论基础.md"}'),p={name:"JS 理论基础.md"};function i(l,a,o,r,c,d){return t(),s("div",null,a[0]||(a[0]=[n(`<p>下面是与原生 JS 有关的知识点汇总</p><h2 id="_1-作用域-作用域链-闭包" tabindex="-1">1.作用域&amp;作用域链&amp;闭包 <a class="header-anchor" href="#_1-作用域-作用域链-闭包" aria-label="Permalink to &quot;1.作用域&amp;作用域链&amp;闭包&quot;">​</a></h2><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>JS作用域是词法作用域，指变量的访问范围。主要分为块作用域、函数作用域、模块作用域和全局作用域</span></span>
<span class="line"><span></span></span>
<span class="line"><span>当 JavaScript 代码需要访问某个变量时,按照嵌套关系从内向外查找变量，直到找到该变量或者到达全局作用域。如果在所有作用域中都找不到变量，则会抛出 ReferenceError</span></span>
<span class="line"><span></span></span>
<span class="line"><span>在JS中函数是一等公民，当函数返回函数的时候就形成闭包</span></span></code></pre></div><h2 id="_2-类与继承和原型链" tabindex="-1">2.类与继承和原型链 <a class="header-anchor" href="#_2-类与继承和原型链" aria-label="Permalink to &quot;2.类与继承和原型链&quot;">​</a></h2><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span></code></pre></div><h2 id="_3-异步" tabindex="-1">3.异步 <a class="header-anchor" href="#_3-异步" aria-label="Permalink to &quot;3.异步&quot;">​</a></h2><p>Ajax -&gt; 事件监听 -&gt; Promise -&gt; 生成器方法 -&gt; async/await</p><h2 id="_4-模块" tabindex="-1">4.模块 <a class="header-anchor" href="#_4-模块" aria-label="Permalink to &quot;4.模块&quot;">​</a></h2>`,8)]))}const u=e(p,[["render",i]]);export{_ as __pageData,u as default};
