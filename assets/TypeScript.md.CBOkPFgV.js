import{_ as i,c as a,o as t,ae as n}from"./chunks/framework.DRC4R4Ij.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"TypeScript.md","filePath":"TypeScript.md"}'),e={name:"TypeScript.md"};function l(p,s,h,r,k,d){return t(),a("div",null,s[0]||(s[0]=[n(`<h2 id="说说你对-typescript-的理解-与-javascript-的区别" tabindex="-1">说说你对 TypeScript 的理解，与 JavaScript 的区别？ <a class="header-anchor" href="#说说你对-typescript-的理解-与-javascript-的区别" aria-label="Permalink to &quot;说说你对 TypeScript 的理解，与 JavaScript 的区别？&quot;">​</a></h2><p>TypeScript（简称 <strong>TS</strong>）是 <strong>JavaScript 的超集</strong>，它在 JavaScript 的基础上增加了 <strong>静态类型检查</strong>、<strong>接口</strong>、<strong>泛型</strong>等功能，使代码更<strong>安全</strong>、<strong>可维护</strong>，并且支持最新的 JavaScript 语法（ESNext）。</p><p><strong>简单来说</strong>：</p><ul><li><strong>JavaScript</strong> 是 <strong>动态类型</strong> 语言，运行时才检查类型错误。</li><li><strong>TypeScript</strong> 是 <strong>静态类型</strong> 语言，在编译阶段就能发现错误，避免运行时报错。</li></ul><h3 id="typescript-和-javascript-的核心区别" tabindex="-1"><strong>TypeScript 和 JavaScript 的核心区别</strong> <a class="header-anchor" href="#typescript-和-javascript-的核心区别" aria-label="Permalink to &quot;**TypeScript 和 JavaScript 的核心区别**&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>对比项</strong></th><th><strong>JavaScript（JS）</strong></th><th><strong>TypeScript（TS）</strong></th></tr></thead><tbody><tr><td><strong>类型系统</strong></td><td><strong>动态类型</strong>（运行时检查）</td><td><strong>静态类型</strong>（编译时检查）</td></tr><tr><td><strong>错误检测</strong></td><td>运行时才会发现错误</td><td>编译阶段就能发现错误</td></tr><tr><td><strong>可读性 &amp; 维护性</strong></td><td>代码无类型提示，易出错</td><td>代码有类型约束，维护更方便</td></tr><tr><td><strong>面向对象支持</strong></td><td>基于原型（Prototype）</td><td>支持接口、泛型、抽象类等</td></tr><tr><td><strong>ES6+ 支持</strong></td><td>需 Babel 转译</td><td>原生支持 ES6+ 语法</td></tr><tr><td><strong>运行方式</strong></td><td>直接在浏览器/Node.js 运行</td><td>需要先编译成 JavaScript</td></tr></tbody></table><h3 id="总结" tabindex="-1"><strong>总结</strong> <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;**总结**&quot;">​</a></h3><ul><li><strong>TypeScript 让 JavaScript 更安全、可维护，减少运行时错误</strong>。</li><li><strong>缺点</strong>：需要<strong>编译</strong>，学习成本稍高，但<strong>大型项目</strong>里非常值得用。</li><li><strong>适用场景</strong>：适用于 <strong>前端（React/Vue/Angular）</strong> 和 <strong>后端（Node.js）</strong> 开发，特别是<strong>大型团队合作</strong>。</li></ul><hr><p><strong>大白话</strong>：TypeScript = <strong>加了类型系统的 JavaScript，更安全、更强大、更适合大型项目</strong>！</p><h2 id="typescript-的数据类型有哪些" tabindex="-1">TypeScript 的数据类型有哪些？ <a class="header-anchor" href="#typescript-的数据类型有哪些" aria-label="Permalink to &quot;TypeScript 的数据类型有哪些？&quot;">​</a></h2><p>有 <code>number</code>、<code>string</code>、<code>boolean</code>、<code>bigint</code>、<code>symbol</code>、<code>null</code>、<code>undefined</code>、<code>Array</code>、<code>Tuple</code>、<code>Object</code>、<code>Enum</code>、<code>any</code>、<code>unknown</code>、<code>void</code>、<code>never</code>、联合类型、交叉类型、类型别名、类型断言、<code>interface</code>、<code>type</code></p><h2 id="说说对-typescript-中命名空间与模块的理解-区别" tabindex="-1">说说对 TypeScript 中命名空间与模块的理解？区别？ <a class="header-anchor" href="#说说对-typescript-中命名空间与模块的理解-区别" aria-label="Permalink to &quot;说说对 TypeScript 中命名空间与模块的理解？区别？&quot;">​</a></h2><h3 id="命名空间" tabindex="-1">命名空间 <a class="header-anchor" href="#命名空间" aria-label="Permalink to &quot;命名空间&quot;">​</a></h3><p>命名空间是一种内部模块，通过 namespace 关键字定义，主要用于在全局作用域下组织代码，避免变量污染。适用于 无需模块化的全局代码组织（如 UMD 库）。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Utils</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> greet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`Hello, \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}!\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用命名空间</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Utils.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">greet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Alice&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span></code></pre></div><ul><li>export 关键字必须添加，否则命名空间内的内容对外不可见。</li><li>命名空间的使用不需要 import，直接通过 Utils.greet() 访问。</li></ul><p>适用场景:</p><ul><li>适用于 浏览器环境（传统 JS 没有模块加载器时）。</li><li>大型项目的全局工具库（如 Utils、MathHelper）。</li></ul><h3 id="模块" tabindex="-1">模块 <a class="header-anchor" href="#模块" aria-label="Permalink to &quot;模块&quot;">​</a></h3><p>TypeScript 的模块是 基于 ES6 模块语法（import/export） 进行组织的，用于 现代前端项目（React、Vue、Node.js 等），需要模块化管理代码，每个 .ts/.tsx 文件默认就是一个模块（如果使用 import/export）。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// utils.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> greet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`Hello, \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}!\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// main.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { greet } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;./utils&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">greet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Bob&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span></code></pre></div><ul><li>export 让 greet 在 utils.ts 之外可见，import 用于引入模块。</li><li>模块的加载是基于 CommonJS（Node.js）或 ES6 模块系统（ESM），需要 import 导入。</li></ul><p>适用场景：</p><ul><li>适用于 所有现代 JS/TS 项目，特别是基于 Node.js、Webpack、Vite、Bun 的项目。</li><li>推荐使用模块，而不是命名空间，因为 ES6 模块是现代 JavaScript 标准。</li></ul><p>总结：现在推荐使用模块而不是命名空间！！！</p><h2 id="typescript-中的泛型是什么" tabindex="-1">TypeScript 中的泛型是什么？ <a class="header-anchor" href="#typescript-中的泛型是什么" aria-label="Permalink to &quot;TypeScript 中的泛型是什么？&quot;">​</a></h2><p>泛型（Generics） 是 TypeScript 提供的一种 让代码更通用、更灵活的方式，它允许你在编写代码时不预先指定具体的类型，而是在使用时再指定具体的类型。</p><p>为什么需要泛型？</p><ul><li>复用性：编写可复用的函数、类、接口，而不局限于某种特定类型。</li><li>类型安全：比 any 更安全，能够在编译时检查类型，而不会丢失类型信息。</li><li>灵活性：让代码适用于不同的数据类型，提高可扩展性。</li></ul><h2 id="什么是-typescript-的方法重载" tabindex="-1">什么是 TypeScript 的方法重载？ <a class="header-anchor" href="#什么是-typescript-的方法重载" aria-label="Permalink to &quot;什么是 TypeScript 的方法重载？&quot;">​</a></h2><p>方法重载（Function Overloading） 是指同一个函数可以根据不同的参数类型和数量，执行不同的逻辑。</p><p>在 TypeScript 中，虽然 JavaScript 不支持真正的函数重载，但 TypeScript 通过函数声明（签名）+ 实现的方式模拟了方法重载。</p><p>在 TypeScript 中，方法重载的语法包括：</p><ol><li>多个函数签名（Overload Signatures）：定义不同参数组合的函数声明。</li><li>一个具体的函数实现（Implementation）：包含具体的逻辑，并兼容所有签名。</li></ol><p>示例：同一个 greet 函数可以接收不同的参数类型</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1️⃣ 定义多个重载签名</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> greet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> greet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">age</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2️⃣ 实现函数（必须兼容所有重载）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> greet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">age</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> undefined</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`Hello, \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}. You are \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">age</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">} years old.\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`Hello, \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}.\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3️⃣ 调用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">greet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Alice&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅ &quot;Hello, Alice.&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">greet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Bob&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅ &quot;Hello, Bob. You are 30 years old.&quot;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// console.log(greet(42));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // ❌ 错误：参数类型不匹配</span></span></code></pre></div><h3 id="typescript-支持的访问修饰符有哪些" tabindex="-1">TypeScript 支持的访问修饰符有哪些？ <a class="header-anchor" href="#typescript-支持的访问修饰符有哪些" aria-label="Permalink to &quot;TypeScript 支持的访问修饰符有哪些？&quot;">​</a></h3><p>在 TypeScript 中，访问修饰符用于控制类的属性和方法的可见性，防止不必要的外部访问，提升代码的封装性和安全性。</p><p>TypeScript 支持的三种访问修饰符：</p><table tabindex="0"><thead><tr><th>修饰符</th><th>作用</th></tr></thead><tbody><tr><td><code>public</code>（默认）</td><td>任何地方都可以访问</td></tr><tr><td><code>private</code></td><td>只能在类的<strong>内部</strong>访问</td></tr><tr><td><code>protected</code></td><td>只能在类的<strong>内部</strong>或<strong>子类</strong>访问</td></tr></tbody></table><h2 id="tsconfig-json-文件有什么作用" tabindex="-1">tsconfig.json 文件有什么作用 <a class="header-anchor" href="#tsconfig-json-文件有什么作用" aria-label="Permalink to &quot;tsconfig.json 文件有什么作用&quot;">​</a></h2><p>tsconfig.json 是 TypeScript 项目的配置文件，用于指定编译选项、文件路径等，控制 TypeScript 代码的编译方式。</p><ol><li>集中管理 TypeScript 编译配置</li><li>提供严格的类型检查</li><li>支持 ES 模块、目标版本、路径别名等</li><li>提高项目可维护性</li><li>支持增量编译、跳过不必要的编译</li></ol><h2 id="typescript-中的-delcare-的关键字有什么作用" tabindex="-1">TypeScript 中的 Delcare 的关键字有什么作用？ <a class="header-anchor" href="#typescript-中的-delcare-的关键字有什么作用" aria-label="Permalink to &quot;TypeScript 中的 Delcare 的关键字有什么作用？&quot;">​</a></h2><p>在 TypeScript 中，<code>declare</code> 关键字用于<strong>声明全局变量、模块、函数、类等</strong>，但不会在编译后生成 JavaScript 代码。它的主要作用是<strong>告诉 TypeScript 这些变量或模块是外部提供的，自己不会实现</strong>。</p><hr><h3 id="_1-declare-的主要用途" tabindex="-1"><strong>1. <code>declare</code> 的主要用途</strong> <a class="header-anchor" href="#_1-declare-的主要用途" aria-label="Permalink to &quot;**1. \`declare\` 的主要用途**&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>用途</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>声明全局变量</strong></td><td>告诉 TypeScript 某个全局变量已存在，但不提供具体实现</td></tr><tr><td><strong>声明全局函数</strong></td><td>告诉 TypeScript 某个全局函数已存在，但不提供实现</td></tr><tr><td><strong>声明模块</strong></td><td>适用于引入 <strong>非 TypeScript</strong> 的第三方库（如 <code>.js</code>）</td></tr><tr><td><strong>声明类型（类型定义文件）</strong></td><td>在 <code>*.d.ts</code> 文件中使用 <code>declare</code> 进行类型定义</td></tr></tbody></table><hr><h3 id="_2-declare-声明全局变量" tabindex="-1"><strong>2. <code>declare</code> 声明全局变量</strong> <a class="header-anchor" href="#_2-declare-声明全局变量" aria-label="Permalink to &quot;**2. \`declare\` 声明全局变量**&quot;">​</a></h3><p>如果你在 JavaScript 代码中引入了一个<strong>没有 TypeScript 类型定义</strong>的全局变量（比如来自 CDN），TypeScript 默认会报错：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window.globalVar); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// globalVar 是一个在 JS 里定义的全局变量</span></span></code></pre></div><p>TypeScript 会提示：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Cannot find name &#39;globalVar&#39;.</span></span></code></pre></div><h3 id="✅-使用-declare-解决" tabindex="-1"><strong>✅ 使用 <code>declare</code> 解决</strong> <a class="header-anchor" href="#✅-使用-declare-解决" aria-label="Permalink to &quot;**✅ 使用 \`declare\` 解决**&quot;">​</a></h3><p>在 <code>.d.ts</code> 文件或 <code>ts</code> 文件中：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> globalVar</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(globalVar); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅ 不会报错</span></span></code></pre></div><p><code>declare</code> 只是<strong>声明</strong>，不生成 JavaScript 代码。</p><hr><h3 id="_3-declare-声明全局函数" tabindex="-1"><strong>3. <code>declare</code> 声明全局函数</strong> <a class="header-anchor" href="#_3-declare-声明全局函数" aria-label="Permalink to &quot;**3. \`declare\` 声明全局函数**&quot;">​</a></h3><p>假设你使用一个<strong>全局函数</strong>，但 TypeScript 不认识它：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">externalFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ❌ 报错：Cannot find name &#39;externalFunction&#39;</span></span></code></pre></div><h3 id="✅-使用-declare-解决-1" tabindex="-1"><strong>✅ 使用 <code>declare</code> 解决</strong> <a class="header-anchor" href="#✅-使用-declare-解决-1" aria-label="Permalink to &quot;**✅ 使用 \`declare\` 解决**&quot;">​</a></h3><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> externalFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">externalFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅ 不报错</span></span></code></pre></div><hr><h3 id="_4-declare-声明全局对象" tabindex="-1"><strong>4. <code>declare</code> 声明全局对象</strong> <a class="header-anchor" href="#_4-declare-声明全局对象" aria-label="Permalink to &quot;**4. \`declare\` 声明全局对象**&quot;">​</a></h3><p>如果有一个全局对象，包含多个属性：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> API</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  baseUrl</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  version</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">API</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.baseUrl);</span></span></code></pre></div><p>这样 TypeScript 知道 <code>API</code> 存在，并能提供类型提示。</p><hr><h3 id="_5-declare-声明模块" tabindex="-1"><strong>5. <code>declare</code> 声明模块</strong> <a class="header-anchor" href="#_5-declare-声明模块" aria-label="Permalink to &quot;**5. \`declare\` 声明模块**&quot;">​</a></h3><p>如果我们使用 <code>import</code> 导入一个<strong>没有 TypeScript 类型的 JavaScript 模块</strong>：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { someFunction } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;myLibrary&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>如果 <code>myLibrary</code> 没有 <code>.d.ts</code> 类型定义文件，TypeScript 会报错：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Cannot find module &#39;myLibrary&#39;.</span></span></code></pre></div><h3 id="✅-使用-declare-module-解决" tabindex="-1"><strong>✅ 使用 <code>declare module</code> 解决</strong> <a class="header-anchor" href="#✅-使用-declare-module-解决" aria-label="Permalink to &quot;**✅ 使用 \`declare module\` 解决**&quot;">​</a></h3><p>在 <code>myLibrary.d.ts</code> 中：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> module</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;myLibrary&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> someFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这样就可以正常使用 <code>import</code> 了。</p><hr><h3 id="_6-declare-在-d-ts-类型定义文件中" tabindex="-1"><strong>6. <code>declare</code> 在 <code>*.d.ts</code> 类型定义文件中</strong> <a class="header-anchor" href="#_6-declare-在-d-ts-类型定义文件中" aria-label="Permalink to &quot;**6. \`declare\` 在 \`*.d.ts\` 类型定义文件中**&quot;">​</a></h3><p>通常，<code>declare</code> 关键字用于 <code>.d.ts</code>（声明文件），帮助 TypeScript 识别外部库的类型。</p><p>例如：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// typings.d.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> module</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;moment&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> format</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">date</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这样，在 TypeScript 代码中：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { format } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;moment&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">format</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;2025-03-13&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>不会报错。</p><hr><h3 id="_7-declare-vs-export" tabindex="-1"><strong>7. <code>declare</code> VS <code>export</code></strong> <a class="header-anchor" href="#_7-declare-vs-export" aria-label="Permalink to &quot;**7. \`declare\` VS \`export\`**&quot;">​</a></h3><p>如果你想要<strong>真正定义</strong>一个变量、函数或类，需要使用 <code>export</code> 而不是 <code>declare</code>：</p><table tabindex="0"><thead><tr><th>关键字</th><th>作用</th></tr></thead><tbody><tr><td><code>declare</code></td><td>只是<strong>声明</strong>，不会编译成 JS 代码</td></tr><tr><td><code>export</code></td><td>真实导出，编译后仍然存在</td></tr></tbody></table><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 只告诉 TS &quot;a 存在&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 真实存在于编译后的 JS 代码中</span></span></code></pre></div><hr><h3 id="_8-总结" tabindex="-1"><strong>8. 总结</strong> <a class="header-anchor" href="#_8-总结" aria-label="Permalink to &quot;**8. 总结**&quot;">​</a></h3><p>✅ <code>declare</code> 关键字用于：</p><ol><li><strong>声明全局变量</strong>（<code>declare var</code> / <code>declare let</code> / <code>declare const</code>）</li><li><strong>声明全局函数</strong>（<code>declare function</code>）</li><li><strong>声明模块</strong>（<code>declare module</code>）</li><li><strong>用于 <code>.d.ts</code> 类型定义文件</strong></li><li><strong>不会在编译后生成 JavaScript 代码</strong></li></ol><h2 id="typescript-的映射文件是什么" tabindex="-1">TypeScript 的映射文件是什么？ <a class="header-anchor" href="#typescript-的映射文件是什么" aria-label="Permalink to &quot;TypeScript 的映射文件是什么？&quot;">​</a></h2><p>TypeScript 的映射文件（Source Map，.map 文件）是一种<strong>调试工具</strong>，用于将<strong>编译后的 JavaScript 代码</strong>映射回 <strong>TypeScript 源代码</strong>，方便在浏览器开发工具中调试。</p><h2 id="什么是类型断言" tabindex="-1">什么是类型断言 <a class="header-anchor" href="#什么是类型断言" aria-label="Permalink to &quot;什么是类型断言&quot;">​</a></h2><p>类型断言允许程序员手动指定一个值的类型。这在需要明确告诉编译器某个值的类型时非常有用。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> someValue</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;this is a string&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> strLength</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (someValue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h2 id="类型守卫-type-guards-是什么" tabindex="-1">类型守卫（Type Guards）是什么 <a class="header-anchor" href="#类型守卫-type-guards-是什么" aria-label="Permalink to &quot;类型守卫（Type Guards）是什么&quot;">​</a></h2><p>类型守卫是一种用于在运行时检查类型的技术，它允许开发人员在特定的作用域内缩小变量的范围，以确保正确推断类型。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> isString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">test</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> test</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> is</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> test </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;string&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(input)) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // input 在此代码块中被收窄为 string 类型</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="什么是联合类型和交叉类型" tabindex="-1">什么是联合类型和交叉类型 <a class="header-anchor" href="#什么是联合类型和交叉类型" aria-label="Permalink to &quot;什么是联合类型和交叉类型&quot;">​</a></h2><p>联合类型表示一个值可以是多种类型中的一种，而交叉类型表示一个新类型，它包含了多个类型的特性。</p><ul><li>联合类型示例：</li></ul><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myVar</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">myVar </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 合法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">myVar </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 123</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 合法</span></span></code></pre></div><ul><li>交叉类型示例：</li></ul><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> C</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 表示同时具备 A 和 B 的特性</span></span></code></pre></div><h2 id="什么是-typescript-中的声明文件" tabindex="-1">什么是 TypeScript 中的声明文件 <a class="header-anchor" href="#什么是-typescript-中的声明文件" aria-label="Permalink to &quot;什么是 TypeScript 中的声明文件&quot;">​</a></h2><p>声明文件（通常以 <code>.d.ts</code> 扩展名结尾）用于描述已有 JavaScript 代码库的类型信息。它们提供了类型定义和元数据，以便在 TypeScript 项目中使用这些库时获得智能感知和类型安全。</p><h2 id="keyof-和-typeof-关键字的作用" tabindex="-1">keyof 和 typeof 关键字的作用？ <a class="header-anchor" href="#keyof-和-typeof-关键字的作用" aria-label="Permalink to &quot;keyof 和 typeof 关键字的作用？&quot;">​</a></h2><ul><li>keyof 索引类型查询操作符 获取索引类型的属性名，构成联合类型。</li><li>typeof 获取一个变量或对象的类型。</li></ul><h2 id="简述工具类型-exclude、omit、merge、intersection、overwrite-的作用。" tabindex="-1">简述工具类型 Exclude、Omit、Merge、Intersection、Overwrite 的作用。 <a class="header-anchor" href="#简述工具类型-exclude、omit、merge、intersection、overwrite-的作用。" aria-label="Permalink to &quot;简述工具类型 Exclude、Omit、Merge、Intersection、Overwrite 的作用。&quot;">​</a></h2><ul><li>Exclude&lt;T, U&gt; 从 T 中排除出可分配给 U 的元素。</li><li>Omit&lt;T, K&gt; 的作用是忽略 T 中的某些属性。</li><li>Merge&lt;O1, O2&gt; 是将两个对象的属性合并。</li><li>Compute&lt;A &amp; B&gt; 是将交叉类型合并</li><li>Intersection&lt;T, U&gt;的作用是取 T 的属性,此属性同样也存在与 U。</li><li>Overwrite&lt;T, U&gt; 是用 U 的属性覆盖 T 的相同属性。</li></ul><h2 id="typescript-中-、-、-、-、-、-等符号的含义" tabindex="-1">TypeScript 中 ?.、??、!、!.、_、** 等符号的含义？ <a class="header-anchor" href="#typescript-中-、-、-、-、-、-等符号的含义" aria-label="Permalink to &quot;TypeScript 中 ?.、??、!、!.、\\_、\\*\\* 等符号的含义？&quot;">​</a></h2><ul><li>?. 可选链 遇到 null 和 undefined 可以立即停止表达式的运行。</li><li>?? 空值合并运算符 当左侧操作数为 null 或 undefined 时，其返回右侧的操作数，否则返回左侧的操作数。</li><li>! 非空断言运算符 x! 将从 x 值域中排除 null 和 undefined</li><li>!. 在变量名后添加，可以断言排除undefined和null类型</li><li>_ 数字分割符 分隔符不会改变数值字面量的值，使人更容易读懂数字 .e.g 1_101_324。</li><li>** 求幂</li></ul>`,119)]))}const g=i(e,[["render",l]]);export{c as __pageData,g as default};
