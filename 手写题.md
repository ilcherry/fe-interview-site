# 手写题

## 函数防抖与节流

```js
// 函数防抖
function debounce(fn, delay) {
  let timer;

  return function () {
    if (timer) {
      clearTimeout(timer);
    }

    timer = setTimeout(() => {
      fn.apply(this, arguments);
    }, delay);
  };
}
```

## 数组去重

```js
function unique(arr) {
  return [...new Set(arr)];
}
```

## 数组拍平

```js
function flatten(arr) {
  return arr?.flat(Infinity);
}
```

## 手写发布订阅

```ts
type Handler = () => void;

class PubSub {
  private subscribers: Map<string, any>;

  constructor() {
    this.subscribers = new Map();
  }

  on(type: string, handler: Handler) {
    const handlers = this.subscribers.get(type);
    if (handlers) {
      this.subscribers.set(type, [...handlers, handler]);
    } else {
      this.subscribers.set(type, [handler]);
    }
  }

  off(type: string) {
    const handlers = this.subscribers.get(type);

    if (handlers) {
      this.subscribers.delete(type);
    }
  }

  emit(type: string, ...args: unknown[]) {
    const handlers = this.subscribers.get(type);

    if (handlers) {
      handlers.forEach((h) => h(...args));
    }
  }
}
```

## 深拷贝

- 使用 JSON.parse 和 JSON.stringify 实现，但是会丢失 Function、underfind 和 null 值

```js
function deepClone(obj) {
  return JSON.parse(JSON.stringify(obj));
}
```

## 函数柯里化

## JSON 转 Tree

```js
// 数据
const students = [
  { id: 1, name: "ming", parentId: 0 },
  { id: 2, name: "hua", parentId: 1 },
  { id: 3, name: "qin", parentId: 1 },
  { id: 4, name: "liu", parentId: 2 },
];

function jsonToTree(data) {
  const map = new Map();

  data.forEach((item) => map.set(item.id, { ...item, children: [] }));

  let tree: any = [];

  data.forEach((item) => {
    if (item.parentId === 0) {
      tree.push(map.get(item.id));
    } else {
      const parent = map.get(item.parentId);

      if (parent) {
        parent.children.push(map.get(item.id));
      }
    }
  });

  return tree;
}
```

## Tree 转 json

## 实现 Promise

## call&apply&bind

```js
// 实现call方法
Function.prototype.myCall = function (context, ...args) {
  context = context || globalThis;

  context["fn"] = this;
  const result = context["fn"](...args);
  delete context["fn"];

  return result;
};
```

## 实现 instanceof 关键字

## 实现 new 关键字

## 实现 Object.assign

## 实现 sleep 方法

```js
function sleep(delay) {
  return new Promise((resolve) => setTimeout(resolve, delay));
}
```
